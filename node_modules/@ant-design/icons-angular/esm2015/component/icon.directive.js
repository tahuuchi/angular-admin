import { Directive, ElementRef, Input, Renderer2 } from '@angular/core';
import { alreadyHasAThemeSuffix, getNameAndNamespace, isIconDefinition, warn, withSuffix } from '../utils';
import { IconService } from './icon.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './icon.service';
function checkMeta(prev, after) {
    return prev.type === after.type && prev.theme === after.theme && prev.twoToneColor === after.twoToneColor;
}
export class IconDirective {
    constructor(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
            }
            else {
                const preMeta = this._getSelfRenderMeta();
                this._iconService.getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor).subscribe(svg => {
                    // avoid race condition, see https://github.com/ant-design/ant-design-icons/issues/315
                    if (checkMeta(preMeta, this._getSelfRenderMeta())) {
                        this._setSVGElement(svg);
                        resolve(svg);
                    }
                    else {
                        resolve(null);
                    }
                });
            }
        });
    }
    _getSelfRenderMeta() {
        return {
            type: this.type,
            theme: this.theme,
            twoToneColor: this.twoToneColor
        };
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (!!theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        var _a;
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            const child = children[i];
            if (((_a = child.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
}
IconDirective.ɵfac = function IconDirective_Factory(t) { return new (t || IconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.IconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IconDirective, selectors: [["", "antIcon", ""]], inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IconDirective.ctorParameters = () => [
    { type: IconService },
    { type: ElementRef },
    { type: Renderer2 }
];
IconDirective.propDecorators = {
    type: [{ type: Input }],
    theme: [{ type: Input }],
    twoToneColor: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IconDirective, [{
        type: Directive,
        args: [{
                selector: '[antIcon]'
            }]
    }], function () { return [{ type: ɵngcc1.IconService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { type: [{
            type: Input
        }], theme: [{
            type: Input
        }], twoToneColor: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnQvaWNvbi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsS0FBSyxFQUVMLFNBQVMsRUFFVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMzRyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQVE3QyxTQUFTLFNBQVMsQ0FBQyxJQUFnQixFQUFFLEtBQWlCO0FBQUksSUFDeEQsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssS0FBSyxDQUFDLFlBQVksQ0FBQztBQUM1RyxDQUFDO0FBS0QsTUFBTSxPQUFPLGFBQWE7QUFBRyxJQUszQixZQUFzQixZQUF5QixFQUFZLFdBQXVCLEVBQVksU0FBb0I7QUFBSSxRQUFoRyxpQkFBWSxHQUFaLFlBQVksQ0FBYTtBQUFDLFFBQVcsZ0JBQVcsR0FBWCxXQUFXLENBQVk7QUFBQyxRQUFXLGNBQVMsR0FBVCxTQUFTLENBQVc7QUFBQyxJQUFFLENBQUM7QUFDeEgsSUFDRSxXQUFXLENBQUMsT0FBc0I7QUFBSSxRQUNwQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO0FBQy9ELFlBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ3pCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRSxPQUFHO0FBQ0wsSUFBWSxXQUFXO0FBQUssUUFDeEIsT0FBTyxJ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LE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFDbkMsUUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQyxZQUFNLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBRSxDQUFDLENBQVMsQ0FBQztBQUN6QyxZQUFNLElBQUksT0FBQSxLQUFLLENBQUMsT0FBTywwQ0FBRSxXQUFXLFFBQU8sS0FBSyxFQUFFO0FBQ2xELGdCQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUM5QyxhQUFPO0FBQ1AsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNIO3lDQTVGQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLFdBQVcsY0FDdEI7ME5BQ0k7QUFBQztBQUF1QyxZQWZwQyxXQUFXO0FBQUksWUFSdEIsVUFBVTtBQUNWLFlBRUEsU0FBUztBQUNWO0FBQUc7QUFDaUIsbUJBbUJsQixLQUFLO0FBQUssb0JBQ1YsS0FBSztBQUFLLDJCQUNWLEtBQUs7QUFBSTs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEljb25EZWZpbml0aW9uLCBUaGVtZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhbHJlYWR5SGFzQVRoZW1lU3VmZml4LCBnZXROYW1lQW5kTmFtZXNwYWNlLCBpc0ljb25EZWZpbml0aW9uLCB3YXJuLCB3aXRoU3VmZml4IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgSWNvblNlcnZpY2UgfSBmcm9tICcuL2ljb24uc2VydmljZSc7XG5cbmludGVyZmFjZSBSZW5kZXJNZXRhIHtcbiAgdHlwZTogc3RyaW5nIHwgSWNvbkRlZmluaXRpb247XG4gIHRoZW1lOiBUaGVtZVR5cGU7XG4gIHR3b1RvbmVDb2xvcjogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBjaGVja01ldGEocHJldjogUmVuZGVyTWV0YSwgYWZ0ZXI6IFJlbmRlck1ldGEpOiBib29sZWFuIHtcbiAgcmV0dXJuIHByZXYudHlwZSA9PT0gYWZ0ZXIudHlwZSAmJiBwcmV2LnRoZW1lID09PSBhZnRlci50aGVtZSAmJiBwcmV2LnR3b1RvbmVDb2xvciA9PT0gYWZ0ZXIudHdvVG9uZUNvbG9yO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbYW50SWNvbl0nXG59KVxuZXhwb3J0IGNsYXNzIEljb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB0eXBlOiBzdHJpbmcgfCBJY29uRGVmaW5pdGlvbjtcbiAgQElucHV0KCkgdGhlbWU6IFRoZW1lVHlwZTtcbiAgQElucHV0KCkgdHdvVG9uZUNvbG9yOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9pY29uU2VydmljZTogSWNvblNlcnZpY2UsIHByb3RlY3RlZCBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlcy50eXBlIHx8IGNoYW5nZXMudGhlbWUgfHwgY2hhbmdlcy50d29Ub25lQ29sb3IpIHtcbiAgICAgIHRoaXMuX2NoYW5nZUljb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGljb24gaW4gdGhlIGN1cnJlbnQgZWxlbWVudC4gUmVtb3ZlIHRoZSBpY29uIHdoZW4gYHR5cGVgIGlzIGZhbHN5LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9jaGFuZ2VJY29uKCk6IFByb21pc2U8U1ZHRWxlbWVudCB8IG51bGw+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U1ZHRWxlbWVudCB8IG51bGw+KHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJTVkdFbGVtZW50KCk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmVNZXRhID0gdGhpcy5fZ2V0U2VsZlJlbmRlck1ldGEoKTtcbiAgICAgICAgdGhpcy5faWNvblNlcnZpY2UuZ2V0UmVuZGVyZWRDb250ZW50KFxuICAgICAgICAgIHRoaXMuX3BhcnNlSWNvblR5cGUodGhpcy50eXBlLCB0aGlzLnRoZW1lKSxcbiAgICAgICAgICB0aGlzLnR3b1RvbmVDb2xvclxuICAgICAgICApLnN1YnNjcmliZShzdmcgPT4ge1xuICAgICAgICAgIC8vIGF2b2lkIHJhY2UgY29uZGl0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudC1kZXNpZ24vYW50LWRlc2lnbi1pY29ucy9pc3N1ZXMvMzE1XG4gICAgICAgICAgaWYgKGNoZWNrTWV0YShwcmVNZXRhLCB0aGlzLl9nZXRTZWxmUmVuZGVyTWV0YSgpKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U1ZHRWxlbWVudChzdmcpO1xuICAgICAgICAgICAgcmVzb2x2ZShzdmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFNlbGZSZW5kZXJNZXRhKCk6IFJlbmRlck1ldGEge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgIHR3b1RvbmVDb2xvcjogdGhpcy50d29Ub25lQ29sb3JcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgaWNvbiB0byB0aGUgc3RhbmRhcmQgZm9ybSwgYW4gYEljb25EZWZpbml0aW9uYCBvciBhIHN0cmluZyBsaWtlICdhY2NvdW50LWJvb2stZmlsbGAgKHdpdGggYSB0aGVtZSBzdWZmaXhlZCkuXG4gICAqIElmIG5hbWVzcGFjZSBpcyBzcGVjaWZpZWQsIGlnbm9yZSB0aGVtZSBiZWNhdXNlIGl0IG1lYW5pbmdsZXNzIGZvciB1c2VycycgaWNvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlXG4gICAqIEBwYXJhbSB0aGVtZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9wYXJzZUljb25UeXBlKHR5cGU6IHN0cmluZyB8IEljb25EZWZpbml0aW9uLCB0aGVtZTogVGhlbWVUeXBlKTogSWNvbkRlZmluaXRpb24gfCBzdHJpbmcge1xuICAgIGlmIChpc0ljb25EZWZpbml0aW9uKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgWyBuYW1lLCBuYW1lc3BhY2UgXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgICAgaWYgKGFscmVhZHlIYXNBVGhlbWVTdWZmaXgobmFtZSkpIHtcbiAgICAgICAgaWYgKCEhdGhlbWUpIHtcbiAgICAgICAgICB3YXJuKGAndHlwZScgJHtuYW1lfSBhbHJlYWR5IGdldHMgYSB0aGVtZSBpbnNpZGUgc28gJ3RoZW1lJyAke3RoZW1lfSB3b3VsZCBiZSBpZ25vcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2l0aFN1ZmZpeChuYW1lLCB0aGVtZSB8fCB0aGlzLl9pY29uU2VydmljZS5kZWZhdWx0VGhlbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0U1ZHRWxlbWVudChzdmc6IFNWR0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9jbGVhclNWR0VsZW1lbnQoKTtcbiAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHN2Zyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NsZWFyU1ZHRWxlbWVudCgpOiB2b2lkIHtcbiAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbC5jaGlsZE5vZGVzO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXSBhcyBhbnk7XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2hpbGQoZWwsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==