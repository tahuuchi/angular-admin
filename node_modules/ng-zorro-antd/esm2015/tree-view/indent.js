/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, Directive, Input } from '@angular/core';
import { animationFrameScheduler, asapScheduler, merge } from 'rxjs';
import { auditTime } from 'rxjs/operators';
import { NzTreeNodeComponent } from './node';
import { NzTreeView } from './tree';
import { getNextSibling, getParent } from './utils';
/**
 * [true, false, false, true] => 1001
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './node';
import * as ɵngcc3 from './tree';

function NzTreeNodeIndentsComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 1);
} if (rf & 2) {
    const isEnd_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("ant-tree-indent-unit-end", !isEnd_r1);
} }
function booleanArrayToString(arr) {
    return arr.map(i => (i ? 1 : 0)).join('');
}
const BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;
export class NzTreeNodeIndentsComponent {
    constructor() {
        this.indents = [];
    }
}
NzTreeNodeIndentsComponent.ɵfac = function NzTreeNodeIndentsComponent_Factory(t) { return new (t || NzTreeNodeIndentsComponent)(); };
NzTreeNodeIndentsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NzTreeNodeIndentsComponent, selectors: [["nz-tree-node-indents"]], hostAttrs: [1, "ant-tree-indent"], inputs: { indents: "indents" }, decls: 1, vars: 1, consts: [["class", "ant-tree-indent-unit", 3, "ant-tree-indent-unit-end", 4, "ngFor", "ngForOf"], [1, "ant-tree-indent-unit"]], template: function NzTreeNodeIndentsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NzTreeNodeIndentsComponent_span_0_Template, 1, 2, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.indents);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
NzTreeNodeIndentsComponent.propDecorators = {
    indents: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzTreeNodeIndentsComponent, [{
        type: Component,
        args: [{
                selector: 'nz-tree-node-indents',
                template: `
    <span class="ant-tree-indent-unit" [class.ant-tree-indent-unit-end]="!isEnd" *ngFor="let isEnd of indents"></span>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'ant-tree-indent'
                }
            }]
    }], function () { return []; }, { indents: [{
            type: Input
        }] }); })();
export class NzTreeNodeIndentLineDirective {
    constructor(treeNode, tree) {
        this.treeNode = treeNode;
        this.tree = tree;
        this.isLast = 'unset';
        this.isLeaf = false;
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.currentIndents = '';
        this.buildIndents();
        this.checkLast();
        /**
         * The dependent data (TreeControl.dataNodes) can be set after node instantiation,
         * and setting the indents can cause frame rate loss if it is set too often.
         */
        this.changeSubscription = merge(this.treeNode._dataChanges, tree._dataSourceChanged)
            .pipe(auditTime(0, BUILD_INDENTS_SCHEDULER))
            .subscribe(() => {
            this.buildIndents();
            this.checkAdjacent();
        });
    }
    getIndents() {
        const indents = [];
        const nodes = this.tree.treeControl.dataNodes;
        const getLevel = this.tree.treeControl.getLevel;
        let parent = getParent(nodes, this.treeNode.data, getLevel);
        while (parent) {
            const parentNextSibling = getNextSibling(nodes, parent, getLevel);
            if (parentNextSibling) {
                indents.unshift(true);
            }
            else {
                indents.unshift(false);
            }
            parent = getParent(nodes, parent, getLevel);
        }
        return indents;
    }
    buildIndents() {
        if (this.treeNode.data) {
            const indents = this.getIndents();
            const diffString = booleanArrayToString(indents);
            if (diffString !== this.currentIndents) {
                this.treeNode.setIndents(this.getIndents());
                this.currentIndents = diffString;
            }
        }
    }
    /**
     * We need to add an class name for the last child node,
     * this result can also be affected when the adjacent nodes are changed.
     */
    checkAdjacent() {
        const nodes = this.tree.treeControl.dataNodes;
        const index = nodes.indexOf(this.treeNode.data);
        const preNode = nodes[index - 1] || null;
        const nextNode = nodes[index + 1] || null;
        if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {
            this.checkLast(index);
        }
        this.preNodeRef = preNode;
        this.nextNodeRef = nextNode;
    }
    checkLast(index) {
        const nodes = this.tree.treeControl.dataNodes;
        this.isLeaf = this.treeNode.isLeaf;
        this.isLast = !getNextSibling(nodes, this.treeNode.data, this.tree.treeControl.getLevel, index);
    }
    ngOnDestroy() {
        this.preNodeRef = null;
        this.nextNodeRef = null;
        this.changeSubscription.unsubscribe();
    }
}
NzTreeNodeIndentLineDirective.ɵfac = function NzTreeNodeIndentLineDirective_Factory(t) { return new (t || NzTreeNodeIndentLineDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NzTreeNodeComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NzTreeView)); };
NzTreeNodeIndentLineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NzTreeNodeIndentLineDirective, selectors: [["nz-tree-node", "nzTreeNodeIndentLine", ""]], hostAttrs: [1, "ant-tree-show-line"], hostVars: 2, hostBindings: function NzTreeNodeIndentLineDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ant-tree-treenode-leaf-last", ctx.isLast && ctx.isLeaf);
    } } });
NzTreeNodeIndentLineDirective.ctorParameters = () => [
    { type: NzTreeNodeComponent },
    { type: NzTreeView }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NzTreeNodeIndentLineDirective, [{
        type: Directive,
        args: [{
                selector: 'nz-tree-node[nzTreeNodeIndentLine]',
                host: {
                    class: 'ant-tree-show-line',
                    '[class.ant-tree-treenode-leaf-last]': 'isLast && isLeaf'
                }
            }]
    }], function () { return [{ type: ɵngcc2.NzTreeNodeComponent }, { type: ɵngcc3.NzTreeView }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZW50LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9jb21wb25lbnRzL3RyZWUtdmlldy9pbmRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUVILE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNoRyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDbkYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM3QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXBDLE9BQU8sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRXBEO0FBQ0E7QUFDQSxHQUFHOzs7Ozs7Ozs7Ozs7QUFDSCxTQUFTLG9CQUFvQixDQUFDLEdBQWM7QUFBSSxJQUM5QyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBRUQsTUFBTSx1QkFBdUIsR0FBRyxPQUFPLHFCQUFxQixLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztBQVl2SCxNQUFNLE9BQU8sMEJBQTBCO0FBQ3ZDLElBWEE7QUFDRyxRQVVRLFlBQU8sR0FBYyxFQUFFLENBQUM7QUFDbkMsSUFBQSxDQUFDO0FBQ0Q7c0RBYkMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxzQkFBc0I7TUFDaEMsUUFBUSxFQUFFLDRIQUVU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SUFDRSxXQUFXO0FBQUssUUFDZCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztBQUMzQixRQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQzVCLFFBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQzFDLElBQUUsQ0FBQztBQUNIO3lEQXRGQyxTQUFTLFNBQUMsa0JBQ1QsUUFBUSxFQUFFLG9DQUFvQyxrQkFDOUMsSUFBSSxFQUFFLHNCQUNKLEtBQUssRUFBRSxvQkFBb0Isc0JBQzNCOytCQUFxQyxFQUFFLGtCQUFrQixrQkFDMUQsY0FDRjs7V0FDSTtBQUFDO0FBQXVELFlBbkNwRCxtQkFBbUI7QUFBSSxZQUN2QixVQUFVO0FBQUc7Ozs7Ozs7Ozs7aUhBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIGFzYXBTY2hlZHVsZXIsIG1lcmdlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE56VHJlZU5vZGVDb21wb25lbnQgfSBmcm9tICcuL25vZGUnO1xuaW1wb3J0IHsgTnpUcmVlVmlldyB9IGZyb20gJy4vdHJlZSc7XG5cbmltcG9ydCB7IGdldE5leHRTaWJsaW5nLCBnZXRQYXJlbnQgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBbdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlXSA9PiAxMDAxXG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW5BcnJheVRvU3RyaW5nKGFycjogYm9vbGVhbltdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGFyci5tYXAoaSA9PiAoaSA/IDEgOiAwKSkuam9pbignJyk7XG59XG5cbmNvbnN0IEJVSUxEX0lOREVOVFNfU0NIRURVTEVSID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgPyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciA6IGFzYXBTY2hlZHVsZXI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ256LXRyZWUtbm9kZS1pbmRlbnRzJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3BhbiBjbGFzcz1cImFudC10cmVlLWluZGVudC11bml0XCIgW2NsYXNzLmFudC10cmVlLWluZGVudC11bml0LWVuZF09XCIhaXNFbmRcIiAqbmdGb3I9XCJsZXQgaXNFbmQgb2YgaW5kZW50c1wiPjwvc3Bhbj5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2FudC10cmVlLWluZGVudCdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOelRyZWVOb2RlSW5kZW50c0NvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGluZGVudHM6IGJvb2xlYW5bXSA9IFtdO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICduei10cmVlLW5vZGVbbnpUcmVlTm9kZUluZGVudExpbmVdJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnYW50LXRyZWUtc2hvdy1saW5lJyxcbiAgICAnW2NsYXNzLmFudC10cmVlLXRyZWVub2RlLWxlYWYtbGFzdF0nOiAnaXNMYXN0ICYmIGlzTGVhZidcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBOelRyZWVOb2RlSW5kZW50TGluZURpcmVjdGl2ZTxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGlzTGFzdDogYm9vbGVhbiB8ICd1bnNldCcgPSAndW5zZXQnO1xuICBpc0xlYWYgPSBmYWxzZTtcbiAgcHJpdmF0ZSBwcmVOb2RlUmVmOiBUIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbmV4dE5vZGVSZWY6IFQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50SW5kZW50czogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgY2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0cmVlTm9kZTogTnpUcmVlTm9kZUNvbXBvbmVudDxUPiwgcHJpdmF0ZSB0cmVlOiBOelRyZWVWaWV3PFQ+KSB7XG4gICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICB0aGlzLmNoZWNrTGFzdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlcGVuZGVudCBkYXRhIChUcmVlQ29udHJvbC5kYXRhTm9kZXMpIGNhbiBiZSBzZXQgYWZ0ZXIgbm9kZSBpbnN0YW50aWF0aW9uLFxuICAgICAqIGFuZCBzZXR0aW5nIHRoZSBpbmRlbnRzIGNhbiBjYXVzZSBmcmFtZSByYXRlIGxvc3MgaWYgaXQgaXMgc2V0IHRvbyBvZnRlbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbiA9IG1lcmdlKHRoaXMudHJlZU5vZGUuX2RhdGFDaGFuZ2VzLCB0cmVlLl9kYXRhU291cmNlQ2hhbmdlZClcbiAgICAgIC5waXBlKGF1ZGl0VGltZSgwLCBCVUlMRF9JTkRFTlRTX1NDSEVEVUxFUikpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5idWlsZEluZGVudHMoKTtcbiAgICAgICAgdGhpcy5jaGVja0FkamFjZW50KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SW5kZW50cygpOiBib29sZWFuW10ge1xuICAgIGNvbnN0IGluZGVudHMgPSBbXTtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMudHJlZS50cmVlQ29udHJvbC5kYXRhTm9kZXM7XG4gICAgY29uc3QgZ2V0TGV2ZWwgPSB0aGlzLnRyZWUudHJlZUNvbnRyb2wuZ2V0TGV2ZWw7XG4gICAgbGV0IHBhcmVudCA9IGdldFBhcmVudChub2RlcywgdGhpcy50cmVlTm9kZS5kYXRhLCBnZXRMZXZlbCk7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgY29uc3QgcGFyZW50TmV4dFNpYmxpbmcgPSBnZXROZXh0U2libGluZyhub2RlcywgcGFyZW50LCBnZXRMZXZlbCk7XG4gICAgICBpZiAocGFyZW50TmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaW5kZW50cy51bnNoaWZ0KHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50cy51bnNoaWZ0KGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IGdldFBhcmVudChub2RlcywgcGFyZW50LCBnZXRMZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEluZGVudHMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJlZU5vZGUuZGF0YSkge1xuICAgICAgY29uc3QgaW5kZW50cyA9IHRoaXMuZ2V0SW5kZW50cygpO1xuICAgICAgY29uc3QgZGlmZlN0cmluZyA9IGJvb2xlYW5BcnJheVRvU3RyaW5nKGluZGVudHMpO1xuICAgICAgaWYgKGRpZmZTdHJpbmcgIT09IHRoaXMuY3VycmVudEluZGVudHMpIHtcbiAgICAgICAgdGhpcy50cmVlTm9kZS5zZXRJbmRlbnRzKHRoaXMuZ2V0SW5kZW50cygpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZW50cyA9IGRpZmZTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdlIG5lZWQgdG8gYWRkIGFuIGNsYXNzIG5hbWUgZm9yIHRoZSBsYXN0IGNoaWxkIG5vZGUsXG4gICAqIHRoaXMgcmVzdWx0IGNhbiBhbHNvIGJlIGFmZmVjdGVkIHdoZW4gdGhlIGFkamFjZW50IG5vZGVzIGFyZSBjaGFuZ2VkLlxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0FkamFjZW50KCk6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmRhdGFOb2RlcztcbiAgICBjb25zdCBpbmRleCA9IG5vZGVzLmluZGV4T2YodGhpcy50cmVlTm9kZS5kYXRhKTtcbiAgICBjb25zdCBwcmVOb2RlID0gbm9kZXNbaW5kZXggLSAxXSB8fCBudWxsO1xuICAgIGNvbnN0IG5leHROb2RlID0gbm9kZXNbaW5kZXggKyAxXSB8fCBudWxsO1xuICAgIGlmICh0aGlzLm5leHROb2RlUmVmICE9PSBuZXh0Tm9kZSB8fCB0aGlzLnByZU5vZGVSZWYgIT09IHByZU5vZGUpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXN0KGluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5wcmVOb2RlUmVmID0gcHJlTm9kZTtcbiAgICB0aGlzLm5leHROb2RlUmVmID0gbmV4dE5vZGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrTGFzdChpbmRleD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy50cmVlLnRyZWVDb250cm9sLmRhdGFOb2RlcztcbiAgICB0aGlzLmlzTGVhZiA9IHRoaXMudHJlZU5vZGUuaXNMZWFmO1xuICAgIHRoaXMuaXNMYXN0ID0gIWdldE5leHRTaWJsaW5nKG5vZGVzLCB0aGlzLnRyZWVOb2RlLmRhdGEsIHRoaXMudHJlZS50cmVlQ29udHJvbC5nZXRMZXZlbCwgaW5kZXgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5wcmVOb2RlUmVmID0gbnVsbDtcbiAgICB0aGlzLm5leHROb2RlUmVmID0gbnVsbDtcbiAgICB0aGlzLmNoYW5nZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iXX0=